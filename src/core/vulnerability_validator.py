"""
Module VulnerabilityValidator pour l'Agent IA de Cybers√©curit√©
G√©n√®re des rapports de validation pour v√©rifier la v√©racit√© des vuln√©rabilit√©s d√©tect√©es
"""

import json
import re
from datetime import datetime
from pathlib import Path
from typing import Dict, List, Any, Optional
from dataclasses import dataclass, asdict

from src.utils.logger import setup_logger

logger = setup_logger(__name__)


@dataclass
class ValidationEvidence:
    """Preuve de d√©tection d'une vuln√©rabilit√©"""
    source: str  # "nmap-script:vulners", "pattern-match", etc.
    raw_output: str  # Output brut du script/scan
    extracted_cvss: Optional[float]
    extracted_severity: Optional[str]
    cve_mentioned: bool
    references_found: List[str]
    confidence_level: str  # "HIGH", "MEDIUM", "LOW"
    validation_notes: str
    detection_location: Optional[Dict[str, Any]] = None  # URL, chemin, fichiers d√©tect√©s

    def to_dict(self) -> Dict[str, Any]:
        return asdict(self)


@dataclass
class VulnerabilityValidation:
    """Validation compl√®te d'une vuln√©rabilit√©"""
    vulnerability_id: str
    is_valid: bool
    confidence_score: float  # 0.0 √† 1.0
    evidence: ValidationEvidence
    cross_references: Dict[str, Any]  # V√©rifications externes (NVD, CVE DB, etc.)
    risk_assessment: str  # "CONFIRMED", "LIKELY", "POSSIBLE", "UNLIKELY"
    recommendations: List[str]

    def to_dict(self) -> Dict[str, Any]:
        result = asdict(self)
        result['evidence'] = self.evidence.to_dict()
        return result


@dataclass
class ScanValidationReport:
    """Rapport de validation complet d'un scan"""
    scan_id: str
    target: str
    scan_date: datetime
    total_vulnerabilities: int
    validated_vulnerabilities: List[VulnerabilityValidation]
    summary: Dict[str, Any]
    
    def to_dict(self) -> Dict[str, Any]:
        result = asdict(self)
        result['scan_date'] = self.scan_date.isoformat()
        result['validated_vulnerabilities'] = [v.to_dict() for v in self.validated_vulnerabilities]
        return result


class VulnerabilityValidator:
    """Valide la v√©racit√© des vuln√©rabilit√©s d√©tect√©es"""
    
    def __init__(self, config: Optional[Dict[str, Any]] = None):
        self.config = config or {}
        self.vulnerability_db_path = Path(__file__).parent.parent.parent / "config" / "vulnerability_db.json"
        self.vulnerability_db = self._load_vulnerability_db()
    
    def _load_vulnerability_db(self) -> Dict[str, Any]:
        """Charge la base de vuln√©rabilit√©s locale"""
        try:
            if self.vulnerability_db_path.exists():
                with open(self.vulnerability_db_path, 'r', encoding='utf-8') as f:
                    return json.load(f)
        except Exception as e:
            logger.warning(f"Impossible de charger la base de vuln√©rabilit√©s: {e}")
        return {}
    
    def validate_vulnerability(
        self,
        vuln: Dict[str, Any],
        scan_context: Optional[Dict[str, Any]] = None
    ) -> VulnerabilityValidation:
        """
        Valide une vuln√©rabilit√© d√©tect√©e
        
        Args:
            vuln: Dictionnaire de vuln√©rabilit√© (VulnerabilityInfo.to_dict())
            scan_context: Contexte du scan (output brut, service d√©tect√©, etc.)
        
        Returns:
            VulnerabilityValidation: Rapport de validation
        """
        vuln_id = vuln.get('vulnerability_id', '')
        detection_method = vuln.get('detection_method', 'unknown')
        description = vuln.get('description', '')
        cvss_score = vuln.get('cvss_score')
        severity = vuln.get('severity', 'UNKNOWN')
        references = vuln.get('references', [])
        cve_ids = vuln.get('cve_ids', [])
        detection_location = vuln.get('detection_location', {})
        
        # Extraire les preuves depuis le contexte
        raw_output = scan_context.get('raw_output', description) if scan_context else description
        
        # Si detection_location contient raw_output, l'utiliser
        if detection_location and detection_location.get('raw_output'):
            raw_output = detection_location.get('raw_output', raw_output)
        
        # Analyser les preuves
        evidence = self._extract_evidence(
            vuln_id=vuln_id,
            detection_method=detection_method,
            raw_output=raw_output,
            cvss_score=cvss_score,
            severity=severity,
            references=references,
            cve_ids=cve_ids,
            detection_location=detection_location
        )
        
        # V√©rifications crois√©es (avec r√©f√©rences pour analyse am√©lior√©e)
        cross_refs = self._cross_reference_validation(vuln_id, cve_ids, references)
        
        # Calculer la confiance
        confidence_score = self._calculate_confidence(evidence, cross_refs)
        
        # √âvaluer le risque
        risk_assessment = self._assess_risk(confidence_score, evidence, cross_refs)
        
        # D√©terminer si c'est valide (seuil ajust√©)
        # Maintenant avec les am√©liorations, on peut valider automatiquement plus de vuln√©rabilit√©s
        is_valid = confidence_score >= 0.60 and risk_assessment in ['CONFIRMED', 'LIKELY']
        
        # Recommandations
        recommendations = self._generate_recommendations(evidence, cross_refs, is_valid)
        
        return VulnerabilityValidation(
            vulnerability_id=vuln_id,
            is_valid=is_valid,
            confidence_score=confidence_score,
            evidence=evidence,
            cross_references=cross_refs,
            risk_assessment=risk_assessment,
            recommendations=recommendations
        )
    
    def _extract_evidence(
        self,
        vuln_id: str,
        detection_method: str,
        raw_output: str,
        cvss_score: Optional[float],
        severity: str,
        references: List[str],
        cve_ids: List[str],
        detection_location: Optional[Dict[str, Any]] = None
    ) -> ValidationEvidence:
        """Extrait les preuves de d√©tection"""
        
        # V√©rifier si la CVE est mentionn√©e dans l'output
        cve_mentioned_in_output = any(cve.upper() in raw_output.upper() for cve in cve_ids) if cve_ids else False
        
        # V√©rifier si la CVE est mentionn√©e dans les r√©f√©rences (preuve forte)
        cve_mentioned_in_references = False
        if cve_ids and references:
            for cve_id in cve_ids:
                cve_upper = cve_id.upper()
                for ref in references:
                    if cve_upper in ref.upper() or f"/cve/{cve_upper}" in ref.lower() or f"/cve-{cve_upper[4:]}" in ref.lower():
                        cve_mentioned_in_references = True
                        break
                if cve_mentioned_in_references:
                    break
        
        # CVE mentionn√©e = dans l'output OU dans les r√©f√©rences
        cve_mentioned = cve_mentioned_in_output or cve_mentioned_in_references
        
        # V√©rifier si on a des r√©f√©rences Vulners/CVE (preuve tr√®s forte)
        has_vulners_references = any('vulners.com' in ref.lower() for ref in references) if references else False
        has_cve_references = any('/cve/' in ref.lower() or '/cve-' in ref.lower() for ref in references) if references else False
        
        # Enrichir raw_output avec les informations de localisation
        location_info = []
        if detection_location:
            if detection_location.get('url'):
                location_info.append(f"URL: {detection_location['url']}")
            if detection_location.get('connection_string'):
                location_info.append(f"Connexion: {detection_location['connection_string']}")
            if detection_location.get('detected_files'):
                location_info.append(f"Fichiers d√©tect√©s: {', '.join(detection_location['detected_files'][:3])}")
            if detection_location.get('detected_paths'):
                location_info.append(f"Chemins d√©tect√©s: {', '.join(detection_location['detected_paths'][:3])}")
        
        if location_info:
            raw_output = f"{raw_output}\n\nüìç Localisation: {' | '.join(location_info)}"
        
        # Extraire CVSS depuis l'output si pas d√©j√† pr√©sent
        extracted_cvss = cvss_score
        if not extracted_cvss:
            cvss_patterns = [
                r'CVSS[:\s]+(\d+\.?\d*)',
                r'\t(\d+\.\d+)\t',  # Format tabul√© vulners
                r'Score[:\s]+(\d+\.?\d*)'
            ]
            for pattern in cvss_patterns:
                match = re.search(pattern, raw_output)
                if match:
                    try:
                        extracted_cvss = float(match.group(1))
                        break
                    except ValueError:
                        continue
        
        # D√©duire la s√©v√©rit√© depuis le CVSS si disponible
        extracted_severity = severity
        if extracted_cvss:
            if extracted_cvss >= 9.0:
                extracted_severity = "CRITICAL"
            elif extracted_cvss >= 7.0:
                extracted_severity = "HIGH"
            elif extracted_cvss >= 4.0:
                extracted_severity = "MEDIUM"
            else:
                extracted_severity = "LOW"
        
        # D√©terminer le niveau de confiance (am√©lior√©)
        confidence_level = "LOW"
        if cve_mentioned and extracted_cvss and (has_vulners_references or has_cve_references):
            confidence_level = "HIGH"  # CVE + CVSS + r√©f√©rences Vulners/CVE = tr√®s fiable
        elif cve_mentioned and extracted_cvss:
            confidence_level = "HIGH"  # CVE + CVSS = fiable
        elif (cve_mentioned_in_references or has_vulners_references) and extracted_cvss:
            confidence_level = "HIGH"  # CVE dans r√©f√©rences + CVSS = fiable m√™me si pas dans output
        elif cve_mentioned or extracted_cvss:
            confidence_level = "MEDIUM"
        elif has_vulners_references or has_cve_references:
            confidence_level = "MEDIUM"  # R√©f√©rences Vulners/CVE = preuve mod√©r√©e
        
        # Notes de validation am√©lior√©es
        notes = []
        if not cve_mentioned_in_output and cve_ids:
            if cve_mentioned_in_references:
                notes.append("‚úÖ CVE trouv√©e dans les r√©f√©rences (preuve valide)")
            else:
                notes.append("‚ö†Ô∏è CVE non mentionn√©e explicitement dans l'output")
        if not extracted_cvss:
            notes.append("‚ö†Ô∏è Score CVSS non trouv√©")
        if not references:
            notes.append("‚ö†Ô∏è Aucune r√©f√©rence externe trouv√©e")
        elif has_vulners_references or has_cve_references:
            notes.append("‚úÖ R√©f√©rences Vulners/CVE trouv√©es (preuve forte)")
        if not notes:
            validation_notes = "‚úÖ Toutes les preuves sont pr√©sentes"
        else:
            validation_notes = " | ".join(notes)
        
        return ValidationEvidence(
            source=detection_method,
            raw_output=raw_output[:500],  # Limiter la taille
            extracted_cvss=extracted_cvss,
            extracted_severity=extracted_severity,
            cve_mentioned=cve_mentioned,  # True si dans output OU dans r√©f√©rences
            references_found=references[:10],  # Limiter √† 10
            confidence_level=confidence_level,
            validation_notes=validation_notes,
            detection_location=detection_location
        )
    
    def _cross_reference_validation(
        self,
        vuln_id: str,
        cve_ids: List[str],
        references: Optional[List[str]] = None
    ) -> Dict[str, Any]:
        """V√©rifications crois√©es avec bases externes"""
        results = {
            "in_local_db": False,
            "in_nvd": None,  # None = non v√©rifi√©, True/False = v√©rifi√©
            "cve_format_valid": False,
            "known_cves": [],
            "has_vulners_references": False,
            "has_cve_references": False,
            "has_multiple_references": False
        }
        
        # V√©rifier dans la base locale
        if self.vulnerability_db:
            known_vulns = self.vulnerability_db.get('known_vulnerabilities', [])
            for known_vuln in known_vulns:
                if vuln_id == known_vuln.get('id') or vuln_id in known_vuln.get('cve_ids', []):
                    results["in_local_db"] = True
                    results["known_cves"] = known_vuln.get('cve_ids', [])
                    break
        
        # V√©rifier le format CVE
        cve_pattern = r'^CVE-\d{4}-\d{4,}$'
        if cve_ids:
            results["cve_format_valid"] = any(re.match(cve_pattern, cve) for cve in cve_ids)
        elif re.match(cve_pattern, vuln_id):
            results["cve_format_valid"] = True
        
        # V√©rifier les r√©f√©rences (preuve suppl√©mentaire)
        if references:
            results["has_vulners_references"] = any('vulners.com' in ref.lower() for ref in references)
            results["has_cve_references"] = any('/cve/' in ref.lower() or '/cve-' in ref.lower() for ref in references)
            results["has_multiple_references"] = len(references) >= 3  # Plusieurs r√©f√©rences = plus fiable
        
        return results
    
    def _calculate_confidence(
        self,
        evidence: ValidationEvidence,
        cross_refs: Dict[str, Any]
    ) -> float:
        """
        Calcule un score de confiance am√©lior√© (0.0 √† 1.0)
        
        Nouvelle logique :
        - CVE mentionn√©e (output ou r√©f√©rences) : +0.25
        - CVSS extrait : +0.20
        - R√©f√©rences Vulners/CVE : +0.25 (preuve tr√®s forte)
        - R√©f√©rences multiples (‚â•3) : +0.10
        - Base locale : +0.15
        - Format CVE valide : +0.05
        
        Total max : 1.0
        """
        score = 0.0
        
        # Preuves de base (am√©lior√©es)
        if evidence.cve_mentioned:
            score += 0.25  # CVE trouv√©e (dans output OU r√©f√©rences)
        
        if evidence.extracted_cvss:
            score += 0.20  # CVSS extrait = preuve technique
        
        # R√©f√©rences Vulners/CVE = preuve tr√®s forte (m√™me sans CVE dans output)
        if cross_refs.get("has_vulners_references") or cross_refs.get("has_cve_references"):
            score += 0.25  # R√©f√©rences Vulners/CVE = tr√®s fiable
        
        # R√©f√©rences multiples = plus fiable
        if cross_refs.get("has_multiple_references"):
            score += 0.10
        
        # R√©f√©rences g√©n√©rales (si pas d√©j√† compt√©)
        if evidence.references_found and not (cross_refs.get("has_vulners_references") or cross_refs.get("has_cve_references")):
            score += 0.10  # R√©f√©rences mais pas Vulners/CVE = preuve mod√©r√©e
        
        # V√©rifications crois√©es
        if cross_refs.get("in_local_db"):
            score += 0.15  # Dans base locale = preuve suppl√©mentaire
        
        if cross_refs.get("cve_format_valid"):
            score += 0.05  # Format valide = v√©rification basique
        
        # Bonus si toutes les conditions sont r√©unies
        if (evidence.cve_mentioned and evidence.extracted_cvss and 
            (cross_refs.get("has_vulners_references") or cross_refs.get("has_cve_references"))):
            score = min(1.0, score + 0.05)  # Bonus pour preuves compl√®tes
        
        return min(1.0, score)
    
    def _assess_risk(
        self,
        confidence_score: float,
        evidence: ValidationEvidence,
        cross_refs: Dict[str, Any]
    ) -> str:
        """
        √âvalue le niveau de risque (seuils ajust√©s)
        
        - CONFIRMED (‚â•0.75) : Preuves tr√®s fortes, validation automatique possible
        - LIKELY (‚â•0.60) : Preuves fortes, validation probable
        - POSSIBLE (‚â•0.40) : Preuves mod√©r√©es, v√©rification recommand√©e
        - UNLIKELY (<0.40) : Preuves faibles, v√©rification manuelle requise
        """
        if confidence_score >= 0.75:
            return "CONFIRMED"
        elif confidence_score >= 0.60:
            return "LIKELY"
        elif confidence_score >= 0.40:
            return "POSSIBLE"
        else:
            return "UNLIKELY"
    
    def _generate_recommendations(
        self,
        evidence: ValidationEvidence,
        cross_refs: Dict[str, Any],
        is_valid: bool
    ) -> List[str]:
        """G√©n√®re des recommandations"""
        recommendations = []
        
        if not is_valid:
            recommendations.append("‚ö†Ô∏è Vuln√©rabilit√© √† v√©rifier manuellement")
        
        if not evidence.cve_mentioned:
            recommendations.append("V√©rifier que la CVE correspond bien au service d√©tect√©")
        
        if not evidence.extracted_cvss:
            recommendations.append("Rechercher le score CVSS sur NVD ou Vulners")
        
        if not cross_refs.get("in_local_db"):
            recommendations.append("Ajouter cette vuln√©rabilit√© √† la base locale pour r√©f√©rence future")
        
        if evidence.confidence_level == "LOW":
            recommendations.append("Consid√©rer comme faux positif potentiel")
        
        return recommendations
    
    def validate_scan(
        self,
        scan_result: Dict[str, Any],
        scan_contexts: Optional[Dict[str, str]] = None
    ) -> ScanValidationReport:
        """
        Valide toutes les vuln√©rabilit√©s d'un scan
        
        Args:
            scan_result: R√©sultat de scan (ScanResult.to_dict())
            scan_contexts: Dict mapping vuln_id -> raw_output (optionnel)
        
        Returns:
            ScanValidationReport: Rapport de validation complet
        """
        vulnerabilities = scan_result.get('vulnerabilities', [])
        validated = []
        
        for vuln in vulnerabilities:
            vuln_id = vuln.get('vulnerability_id', '')
            # Utiliser detection_location si disponible, sinon description
            detection_location = vuln.get('detection_location', {})
            raw_output = detection_location.get('raw_output') if detection_location else None
            if not raw_output:
                raw_output = scan_contexts.get(vuln_id, vuln.get('description', '')) if scan_contexts else vuln.get('description', '')
            context = {
                'raw_output': raw_output
            }
            validation = self.validate_vulnerability(vuln, context)
            validated.append(validation)
        
        # Calculer le r√©sum√©
        total = len(validated)
        confirmed = sum(1 for v in validated if v.risk_assessment == 'CONFIRMED')
        likely = sum(1 for v in validated if v.risk_assessment == 'LIKELY')
        possible = sum(1 for v in validated if v.risk_assessment == 'POSSIBLE')
        unlikely = sum(1 for v in validated if v.risk_assessment == 'UNLIKELY')
        
        avg_confidence = sum(v.confidence_score for v in validated) / total if total > 0 else 0.0
        
        summary = {
            "total_vulnerabilities": total,
            "confirmed": confirmed,
            "likely": likely,
            "possible": possible,
            "unlikely": unlikely,
            "average_confidence": round(avg_confidence, 2),
            "validation_rate": round((confirmed + likely) / total * 100, 1) if total > 0 else 0.0
        }
        
        return ScanValidationReport(
            scan_id=scan_result.get('scan_id', 'unknown'),
            target=scan_result.get('target', 'unknown'),
            scan_date=datetime.utcnow(),
            total_vulnerabilities=total,
            validated_vulnerabilities=validated,
            summary=summary
        )

